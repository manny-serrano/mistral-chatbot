import { NextRequest, NextResponse } from "next/server";
import fs from "fs";
import path from "path";
import { getUserFromSession } from "../../../lib/auth-utils";

const REPORTS_DIR = path.join(process.cwd(), "../cybersecurity_reports");

export async function GET(request: NextRequest) {
  try {
    // Check authentication
    const user = getUserFromSession(request);
    if (!user) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
    }

    const url = new URL(request.url);
    const reportId = url.searchParams.get('id');
    const format = url.searchParams.get('format') || 'json';

    if (!reportId) {
      return NextResponse.json({ error: 'Report ID is required' }, { status: 400 });
    }

    const reportPath = path.join(REPORTS_DIR, `${reportId}.json`);
    
    if (!fs.existsSync(reportPath)) {
      return NextResponse.json({ error: 'Report not found' }, { status: 404 });
    }

    try {
      const reportContent = fs.readFileSync(reportPath, 'utf-8');
      const reportData = JSON.parse(reportContent);
      
      if (format === 'json') {
        // Return JSON download
        const headers = new Headers();
        headers.set('Content-Type', 'application/json');
        headers.set('Content-Disposition', `attachment; filename="${reportId}.json"`);
        
        return new NextResponse(reportContent, { headers });
      } 
      
      if (format === 'summary') {
        // Return a formatted summary
        const summary = generateReportSummary(reportData);
        const headers = new Headers();
        headers.set('Content-Type', 'text/plain');
        headers.set('Content-Disposition', `attachment; filename="${reportId}_summary.txt"`);
        
        return new NextResponse(summary, { headers });
      }

      return NextResponse.json({ error: 'Unsupported format' }, { status: 400 });
    } catch (error) {
      console.error('Error reading report:', error);
      return NextResponse.json({ error: 'Error reading report file' }, { status: 500 });
    }
  } catch (error) {
    console.error('Error in download API:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

function generateReportSummary(reportData: any): string {
  const metadata = reportData.metadata || {};
  const executive = reportData.executive_summary || {};
  const traffic = reportData.network_traffic_overview?.basic_stats || {};
  const findings = reportData.security_findings || {};

  let summary = `CYBERSECURITY REPORT SUMMARY
${'='.repeat(50)}

Report Information:
- Title: ${metadata.report_title || 'N/A'}
- Generated: ${metadata.generation_date || 'N/A'}
- Analysis Period: ${metadata.reporting_period || 'N/A'}
- Duration: ${metadata.analysis_duration_hours || 0} hours

Executive Summary:
- Overall Risk Level: ${executive.overall_risk_level || 'N/A'}
- Critical Issues: ${executive.critical_issues_count || 0}
- Recommendations Priority: ${executive.recommendations_priority || 'N/A'}

Network Traffic Overview:
- Total Flows Analyzed: ${traffic.total_flows?.toLocaleString() || '0'}
- Total Bytes: ${((traffic.total_bytes || 0) / 1024 / 1024 / 1024).toFixed(2)} GB
- Average Bandwidth: ${traffic.average_mbps || 0} Mbps

Security Findings:
`;

  // Add security findings summary
  Object.entries(findings).forEach(([category, finding]: [string, any]) => {
    if (finding && typeof finding === 'object' && finding.severity) {
      summary += `- ${category.replace(/_/g, ' ').toUpperCase()}: ${finding.severity} severity\n`;
    }
  });

  summary += `

Key Findings:
`;
  if (executive.key_findings && Array.isArray(executive.key_findings)) {
    executive.key_findings.forEach((finding: string, index: number) => {
      summary += `${index + 1}. ${finding}\n`;
    });
  }

  summary += `
${'='.repeat(50)}
Generated by: ${metadata.generated_by || 'LEVANT AI Security Platform'}
Report Version: ${metadata.report_version || 'N/A'}
`;

  return summary;
} 